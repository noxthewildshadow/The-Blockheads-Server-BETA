/*
 * Name Exploit Fixer V10 (ENet Socket Killer)
 * 1. Blocks Invalid Names at Network Gate.
 * 2. Uses low-level 'enet_peer_disconnect_now' to kill the socket.
 * 3. Fallback to Silent Block (Ghosting) if symbols aren't found.
 */

#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <unistd.h>
#include <dlfcn.h>
#include <pthread.h>
#include <stdbool.h>
#include <stdint.h>
#include <objc/runtime.h>
#include <objc/message.h>

// -----------------------------------------------------------------------------
// CONFIGURATION
// -----------------------------------------------------------------------------

#define TARGET_CLASS "BHNetServerMatch"
#define TARGET_SEL_1 "clientPlayerInformationRecieved:fromPeer:" 
#define TARGET_SEL_2 "clientApprovedWithInfo:"                   

// ENet Structures (Opaque)
typedef struct _ENetPeer ENetPeer;
typedef void (*DisconnectFunc)(ENetPeer *, uint32_t);

// Function Pointers
static DisconnectFunc real_enet_peer_disconnect_now = NULL;
static void (*original_auth)(id, SEL, id, id) = NULL;
static void (*original_approve)(id, SEL, id) = NULL;

// Helper Typos
typedef id (*ObjForKeyFunc)(id, SEL, id);  
typedef const char* (*Utf8Func)(id, SEL);
typedef unsigned long (*LengthFunc)(id, SEL);
typedef void* (*ValuePointerFunc)(id, SEL); 

// -----------------------------------------------------------------------------
// SYMBOL RESOLUTION
// -----------------------------------------------------------------------------
void resolve_enet_symbols() {
    // Get handle to the main executable
    void* handle = dlopen(NULL, RTLD_NOW);
    if (!handle) {
        printf("[NameGuard] ERROR: Could not open main executable handle.\n");
        return;
    }

    // Try to find the nuclear option
    real_enet_peer_disconnect_now = (DisconnectFunc)dlsym(handle, "enet_peer_disconnect_now");

    if (real_enet_peer_disconnect_now) {
        printf("[NameGuard] SUCCESS: Found 'enet_peer_disconnect_now' at %p.\n", real_enet_peer_disconnect_now);
    } else {
        printf("[NameGuard] WARNING: Could not find ENet functions. Will use Silent Block.\n");
    }
}

// -----------------------------------------------------------------------------
// HELPER: Extract Name
// -----------------------------------------------------------------------------
const char* get_alias_safe(id dict) {
    if (!dict) return NULL;
    SEL sObjectForKey = sel_registerName("objectForKey:");
    Class clsString = objc_getClass("NSString");
    SEL sStringWithUTF8 = sel_registerName("stringWithUTF8String:");
    
    id (*strFactory)(id, SEL, const char*) = (id (*)(id, SEL, const char*))method_getImplementation(class_getClassMethod(clsString, sStringWithUTF8));
    id keyAlias = strFactory((id)clsString, sStringWithUTF8, "alias");

    id valString = NULL;
    if (class_getInstanceMethod(object_getClass(dict), sObjectForKey)) {
         id (*f)(id, SEL, id) = (id (*)(id, SEL, id))method_getImplementation(class_getInstanceMethod(object_getClass(dict), sObjectForKey));
         valString = f(dict, sObjectForKey, keyAlias);
    }
    if (!valString) return NULL;

    SEL sLength = sel_registerName("length");
    if (class_getInstanceMethod(object_getClass(valString), sLength)) {
        unsigned long (*fLen)(id, SEL) = (unsigned long (*)(id, SEL))method_getImplementation(class_getInstanceMethod(object_getClass(valString), sLength));
        if (fLen(valString, sLength) == 0) return NULL;
    }

    SEL sUTF8 = sel_registerName("UTF8String");
    if (class_getInstanceMethod(object_getClass(valString), sUTF8)) {
        const char* (*f)(id, SEL) = (const char* (*)(id, SEL))method_getImplementation(class_getInstanceMethod(object_getClass(valString), sUTF8));
        return f(valString, sUTF8);
    }
    return NULL;
}

// -----------------------------------------------------------------------------
// HELPER: Get Raw ENet Peer
// -----------------------------------------------------------------------------
ENetPeer* get_raw_peer(id peerWrapper) {
    if (!peerWrapper) return NULL;
    
    SEL sPtrVal = sel_registerName("pointerValue");
    if (class_getInstanceMethod(object_getClass(peerWrapper), sPtrVal)) {
        ValuePointerFunc f = (ValuePointerFunc)method_getImplementation(class_getInstanceMethod(object_getClass(peerWrapper), sPtrVal));
        return (ENetPeer*)f(peerWrapper, sPtrVal);
    }
    return NULL;
}

// -----------------------------------------------------------------------------
// LOGIC
// -----------------------------------------------------------------------------
bool is_name_safe(const char* str) {
    if (!str) return false;
    size_t len = strlen(str);
    if (len < 1 || len > 16) return false;
    for (int i = 0; i < len; i++) {
        char c = str[i];
        if (!isalnum(c) && c != '_') return false;
    }
    return true;
}

void hook_PacketRecv(id self, SEL _cmd, id infoDict, id peerWrapper) {
    const char* alias = get_alias_safe(infoDict);

    if (!is_name_safe(alias)) {
        printf("[NameGuard] ðŸ›‘ BLOCKED at Packet Gate.\n");
        
        // Try Hard Kick
        ENetPeer* rawPeer = get_raw_peer(peerWrapper);
        if (rawPeer && real_enet_peer_disconnect_now) {
            printf("[NameGuard] Killing socket connection...\n");
            real_enet_peer_disconnect_now(rawPeer, 0);
            printf("[NameGuard] Socket terminated.\n");
        } else {
            // Fallback
            printf("[NameGuard] Attack Mitigated (Silent Mode - Ghosting).\n");
        }
        return; // BLOCK
    }

    if (original_auth) original_auth(self, _cmd, infoDict, peerWrapper);
}

void hook_Approve(id self, SEL _cmd, id infoDict) {
    const char* alias = get_alias_safe(infoDict);
    if (!is_name_safe(alias)) {
        printf("[NameGuard] ðŸ›‘ BLOCKED at Approval Gate.\n");
        return;
    }
    if (original_approve) original_approve(self, _cmd, infoDict);
}

// -----------------------------------------------------------------------------
// INIT
// -----------------------------------------------------------------------------
static void *patchThread(void *arg) {
    printf("[NameGuard] Loading V10 (Socket Killer)...\n");
    sleep(1); 
    
    // 1. Resolve Symbols
    resolve_enet_symbols();

    // 2. Setup Pool
    Class clsPool = objc_getClass("NSAutoreleasePool");
    SEL sNew = sel_registerName("new");
    SEL sDrain = sel_registerName("drain");
    id (*newPool)(id, SEL) = (id (*)(id, SEL))method_getImplementation(class_getClassMethod(clsPool, sNew));
    void (*drainPool)(id, SEL) = (void (*)(id, SEL))method_getImplementation(class_getInstanceMethod(clsPool, sDrain));
    id pool = newPool((id)clsPool, sNew);

    // 3. Install Hooks
    Class targetClass = objc_getClass(TARGET_CLASS);
    if (targetClass) {
        SEL s1 = sel_registerName(TARGET_SEL_1);
        Method m1 = class_getInstanceMethod(targetClass, s1);
        if (m1) {
            original_auth = (void (*)(id, SEL, id, id))method_getImplementation(m1);
            method_setImplementation(m1, (IMP)hook_PacketRecv);
            printf("[NameGuard] Packet Filter: Active.\n");
        }

        SEL s2 = sel_registerName(TARGET_SEL_2);
        Method m2 = class_getInstanceMethod(targetClass, s2);
        if (m2) {
            original_approve = (void (*)(id, SEL, id))method_getImplementation(m2);
            method_setImplementation(m2, (IMP)hook_Approve);
            printf("[NameGuard] Approval Filter: Active.\n");
        }
    } else {
        printf("[NameGuard] ERROR: Class %s not found.\n", TARGET_CLASS);
    }

    drainPool(pool, sDrain);
    return NULL;
}

__attribute__((constructor))
static void init_hook() {
    pthread_t t;
    pthread_create(&t, NULL, patchThread, NULL);
}
