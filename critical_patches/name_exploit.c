/*
 * NameGuard - Security Patch
 * Blocks invalid names & zombie connections
 */

#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <unistd.h>
#include <dlfcn.h>
#include <pthread.h>
#include <stdbool.h>
#include <stdint.h>
#include <objc/runtime.h>
#include <objc/message.h>

// --- Configuration ---
#define CLASS_MATCH   "BHNetServerMatch"
#define CLASS_CLIENT  "ServerClient"

#define SEL_AUTH      "clientPlayerInformationRecieved:fromPeer:" 
#define SEL_DISCONN   "clientDisconnected:wasKick:"
#define SEL_RECONN    "clientReconnected" 

// --- ENet Types & Globals ---
typedef struct _ENetPeer ENetPeer;
typedef void (*DisconnectFunc)(ENetPeer *, uint32_t);
typedef void (*ResetFunc)(ENetPeer *); 

static DisconnectFunc real_enet_peer_disconnect_now = NULL;
static ResetFunc real_enet_peer_reset = NULL;

static void (*original_auth)(id, SEL, id, id) = NULL;
static void (*original_disconnect)(id, SEL, id, bool) = NULL;

// --- Helper Types ---
typedef void* (*ValuePointerFunc)(id, SEL); 

// -----------------------------------------------------------------------------
void resolve_enet_symbols() {
    void* handle = dlopen(NULL, RTLD_NOW);
    if (!handle) return;
    
    real_enet_peer_disconnect_now = (DisconnectFunc)dlsym(handle, "enet_peer_disconnect_now");
    real_enet_peer_reset = (ResetFunc)dlsym(handle, "enet_peer_reset");
}

// -----------------------------------------------------------------------------
const char* get_alias_safe(id dict) {
    if (!dict) return NULL;
    
    SEL sObjectForKey = sel_registerName("objectForKey:");
    SEL sStringWithUTF8 = sel_registerName("stringWithUTF8String:");
    SEL sLength = sel_registerName("length");
    SEL sUTF8 = sel_registerName("UTF8String");

    Class clsString = objc_getClass("NSString");
    
    id (*strFactory)(id, SEL, const char*) = (id (*)(id, SEL, const char*))method_getImplementation(class_getClassMethod(clsString, sStringWithUTF8));
    id keyAlias = strFactory((id)clsString, sStringWithUTF8, "alias");

    id valString = NULL;
    if (class_getInstanceMethod(object_getClass(dict), sObjectForKey)) {
         id (*f)(id, SEL, id) = (id (*)(id, SEL, id))method_getImplementation(class_getInstanceMethod(object_getClass(dict), sObjectForKey));
         valString = f(dict, sObjectForKey, keyAlias);
    }
    
    if (!valString) return NULL; 

    if (class_getInstanceMethod(object_getClass(valString), sLength)) {
        unsigned long (*fLen)(id, SEL) = (unsigned long (*)(id, SEL))method_getImplementation(class_getInstanceMethod(object_getClass(valString), sLength));
        if (fLen(valString, sLength) == 0) return NULL;
    }

    if (class_getInstanceMethod(object_getClass(valString), sUTF8)) {
        const char* (*f)(id, SEL) = (const char* (*)(id, SEL))method_getImplementation(class_getInstanceMethod(object_getClass(valString), sUTF8));
        return f(valString, sUTF8);
    }
    return NULL;
}

ENetPeer* get_raw_peer(id peerWrapper) {
    if (!peerWrapper) return NULL;
    SEL sPtrVal = sel_registerName("pointerValue");
    if (class_getInstanceMethod(object_getClass(peerWrapper), sPtrVal)) {
        ValuePointerFunc f = (ValuePointerFunc)method_getImplementation(class_getInstanceMethod(object_getClass(peerWrapper), sPtrVal));
        return (ENetPeer*)f(peerWrapper, sPtrVal);
    }
    return NULL;
}

// -----------------------------------------------------------------------------
bool is_name_safe(const char* str) {
    if (!str) return false;
    size_t len = strlen(str);
    
    if (len < 1 || len > 16) return false;

    for (int i = 0; i < len; i++) {
        char c = str[i];
        if (!isalnum(c) && c != '_') return false;
    }
    return true;
}

// -----------------------------------------------------------------------------
// Hooks
void hook_PacketRecv(id self, SEL _cmd, id infoDict, id peerWrapper) {
    const char* alias = get_alias_safe(infoDict);

    if (!is_name_safe(alias)) {
        printf("[NameGuard] Blocked invalid connection attempt.\n");
        
        ENetPeer* rawPeer = get_raw_peer(peerWrapper);
        if (rawPeer && real_enet_peer_disconnect_now) {
            real_enet_peer_disconnect_now(rawPeer, 0);
        }
        return; 
    }

    if (original_auth) original_auth(self, _cmd, infoDict, peerWrapper);
}

void hook_Reconnect_Neutralizer(id self, SEL _cmd) {
    // Empty
}

void hook_Disconnect_Cleanup(id self, SEL _cmd, id peerWrapper, bool wasKick) {
    if (original_disconnect) {
        original_disconnect(self, _cmd, peerWrapper, wasKick);
    }

    ENetPeer* rawPeer = get_raw_peer(peerWrapper);
    if (rawPeer && real_enet_peer_reset) {
        real_enet_peer_reset(rawPeer);
    }
}

// -----------------------------------------------------------------------------
static void *NameGuard_InitThread(void *arg) {
    // Spin-lock
    int checks = 0;
    while (!objc_getClass(CLASS_MATCH) || !objc_getClass(CLASS_CLIENT)) {
        usleep(1000); 
        checks++;
        if (checks > 15000) return NULL; 
    }
    
    resolve_enet_symbols();

    Class clsMatch = objc_getClass(CLASS_MATCH);
    if (clsMatch) {
        SEL s1 = sel_registerName(SEL_AUTH);
        Method m1 = class_getInstanceMethod(clsMatch, s1);
        if (m1) {
            original_auth = (void (*)(id, SEL, id, id))method_getImplementation(m1);
            method_setImplementation(m1, (IMP)hook_PacketRecv);
        }
        SEL sDisc = sel_registerName(SEL_DISCONN);
        Method mDisc = class_getInstanceMethod(clsMatch, sDisc);
        if (mDisc) {
            original_disconnect = (void (*)(id, SEL, id, bool))method_getImplementation(mDisc);
            method_setImplementation(mDisc, (IMP)hook_Disconnect_Cleanup);
        }
    }

    Class clsClient = objc_getClass(CLASS_CLIENT);
    if (clsClient) {
        SEL sReconn = sel_registerName(SEL_RECONN);
        Method mReconn = class_getInstanceMethod(clsClient, sReconn);
        if (mReconn) {
            method_setImplementation(mReconn, (IMP)hook_Reconnect_Neutralizer);
        }
    }
    
    return NULL;
}

__attribute__((constructor))
static void NameGuard_Entry() {
    pthread_t t;
    pthread_create(&t, NULL, NameGuard_InitThread, NULL);
}
