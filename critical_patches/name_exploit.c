/*
 * The Blockheads Server - Auth Blocker v11.0
 * * Target: BHNetServerMatch (Network Handshake)
 * * Logic: Intercepts login packet (0x1f) to validate username/alias.
 * * Policy:
 * - Length: 1 to 16 chars.
 * - Allowed: [a-z], [A-Z], [0-9], [_].
 * - Blocks: Empty strings, spaces, null bytes, special symbols.
 */

#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <unistd.h>
#include <dlfcn.h>
#include <pthread.h>
#include <stdbool.h>
#include <objc/runtime.h>
#include <objc/message.h>

// Selector for the login handshake
#define TARGET_SEL "clientPlayerInformationRecieved:fromPeer:"

// Func types
typedef void (*AuthFunc)(id, SEL, id, id); 
typedef id (*ObjForKeyFunc)(id, SEL, id);  
typedef const char* (*Utf8Func)(id, SEL);

static AuthFunc original_auth = NULL;

// -----------------------------------------------------------------------------
// Validation Logic
// -----------------------------------------------------------------------------
bool is_valid_name(const char* str) {
    if (!str) return false;
    size_t len = strlen(str);

    // Rule: Min 1, Max 16
    if (len < 1 || len > 16) return false;

    // Rule: Alphanumeric + Underscore ONLY
    for (int i = 0; i < len; i++) {
        char c = str[i];
        // Block invisible unicode/control chars
        if (!isascii(c)) return false; 
        // Allow A-Z, 0-9, _
        if (!isalnum(c) && c != '_') return false;
    }
    return true;
}

// -----------------------------------------------------------------------------
// Helper: Parse Info Dict
// -----------------------------------------------------------------------------
const char* get_alias_from_dict(id dict) {
    if (!dict) return NULL;
    
    SEL sObjectForKey = sel_registerName("objectForKey:");
    
    // Alloc NSString @"alias"
    Class clsString = objc_getClass("NSString");
    SEL sStringWithUTF8 = sel_registerName("stringWithUTF8String:");
    id (*strFactory)(id, SEL, const char*) = (id (*)(id, SEL, const char*))method_getImplementation(class_getClassMethod(clsString, sStringWithUTF8));
    
    // Create key (casted to id to silence warnings)
    id keyAlias = strFactory((id)clsString, sStringWithUTF8, "alias");

    // Get Value
    id valString = NULL;
    if (class_getInstanceMethod(object_getClass(dict), sObjectForKey)) {
         ObjForKeyFunc f = (ObjForKeyFunc)method_getImplementation(class_getInstanceMethod(object_getClass(dict), sObjectForKey));
         valString = f(dict, sObjectForKey, keyAlias);
    }

    if (!valString) return NULL;

    // Convert to C-String
    SEL sUTF8 = sel_registerName("UTF8String");
    if (class_getInstanceMethod(object_getClass(valString), sUTF8)) {
        Utf8Func f = (Utf8Func)method_getImplementation(class_getInstanceMethod(object_getClass(valString), sUTF8));
        return f(valString, sUTF8);
    }

    return NULL;
}

// -----------------------------------------------------------------------------
// HOOK: Gatekeeper
// -----------------------------------------------------------------------------
void hook_Auth(id self, SEL _cmd, id infoDict, id peer) {
    
    const char* alias = get_alias_from_dict(infoDict);

    if (!is_valid_name(alias)) {
        printf("[AuthBlocker] REJECTED: Name '%s' violates policy (1-16 alphanumeric).\n", alias ? alias : "NULL/EMPTY");
        // Drop packet. Connection hangs/fails safely.
        return; 
    }

    // Valid -> Pass to game
    if (original_auth) {
        original_auth(self, _cmd, infoDict, peer);
    }
}

// -----------------------------------------------------------------------------
// Init & Target Search
// -----------------------------------------------------------------------------
void try_hook_class(const char* className, SEL selector) {
    if (original_auth != NULL) return;

    Class cls = objc_getClass(className);
    if (!cls) return;

    Method method = class_getInstanceMethod(cls, selector);
    if (method) {
        printf("[AuthBlocker] Target acquired: %s.\n", className);
        original_auth = (AuthFunc)method_getImplementation(method);
        method_setImplementation(method, (IMP)hook_Auth);
        printf("[AuthBlocker] Hook installed successfully.\n");
    }
}

static void *patchThread(void *arg) {
    printf("[AuthBlocker] Initializing Name Policy (1-16 chars)...\n");
    sleep(2); 
    
    // Setup Memory Pool
    Class clsPool = objc_getClass("NSAutoreleasePool");
    SEL sNew = sel_registerName("new");
    SEL sDrain = sel_registerName("drain");
    id (*newPool)(id, SEL) = (id (*)(id, SEL))method_getImplementation(class_getClassMethod(clsPool, sNew));
    void (*drainPool)(id, SEL) = (void (*)(id, SEL))method_getImplementation(class_getInstanceMethod(clsPool, sDrain));
    id pool = newPool((id)clsPool, sNew);

    SEL selector = sel_registerName(TARGET_SEL);

    // Target list based on confirmed logs
    try_hook_class("BHNetServerMatch", selector); 
    try_hook_class("BHMatch", selector);
    try_hook_class("BHServer", selector);

    if (!original_auth) {
        printf("[AuthBlocker] FATAL: Auth method not found.\n");
    }

    drainPool(pool, sDrain);
    return NULL;
}

__attribute__((constructor))
static void init_hook() {
    pthread_t t;
    pthread_create(&t, NULL, patchThread, NULL);
}
