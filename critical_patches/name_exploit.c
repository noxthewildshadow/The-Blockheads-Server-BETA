/*
 * NameGuard - Security Patch for The Blockheads Server
 * * Features:
 * 1. Strict Name Validation: Blocks NULL, empty, and non-alphanumeric names.
 * 2. Socket Killer: Uses 'enet_peer_disconnect_now' to drop malicious packets instantly.
 * 3. Session Shredder: Resets ENet peers upon disconnect to prevent "Zombie Slot" hijacking.
 * 4. Reconnect Seal: Neutralizes 'clientReconnected' to force full authentication.
 * 5. Instant Load: Mitigates startup race conditions using a micro-sleep loop.
 */

#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <unistd.h>
#include <dlfcn.h>
#include <pthread.h>
#include <stdbool.h>
#include <stdint.h>
#include <objc/runtime.h>
#include <objc/message.h>

// --- Configuration ---
#define CLASS_MATCH   "BHNetServerMatch"
#define CLASS_CLIENT  "ServerClient"

#define SEL_AUTH      "clientPlayerInformationRecieved:fromPeer:" 
#define SEL_DISCONN   "clientDisconnected:wasKick:"
#define SEL_RECONN    "clientReconnected" 

// --- ENet Types & Globals ---
typedef struct _ENetPeer ENetPeer;
typedef void (*DisconnectFunc)(ENetPeer *, uint32_t);
typedef void (*ResetFunc)(ENetPeer *); 

static DisconnectFunc real_enet_peer_disconnect_now = NULL;
static ResetFunc real_enet_peer_reset = NULL;

static void (*original_auth)(id, SEL, id, id) = NULL;
static void (*original_disconnect)(id, SEL, id, bool) = NULL;

// --- Helper Types ---
typedef void* (*ValuePointerFunc)(id, SEL); 

// -----------------------------------------------------------------------------
// Symbol Resolution: Loads low-level ENet functions from the main binary
// -----------------------------------------------------------------------------
void resolve_enet_symbols() {
    void* handle = dlopen(NULL, RTLD_NOW);
    if (!handle) {
        printf("[NameGuard] ERROR: Could not open main executable handle.\n");
        return;
    }
    
    real_enet_peer_disconnect_now = (DisconnectFunc)dlsym(handle, "enet_peer_disconnect_now");
    real_enet_peer_reset = (ResetFunc)dlsym(handle, "enet_peer_reset");
    
    if (real_enet_peer_disconnect_now) printf("[NameGuard] Loaded: enet_peer_disconnect_now\n");
    if (real_enet_peer_reset) printf("[NameGuard] Loaded: enet_peer_reset\n");
}

// -----------------------------------------------------------------------------
// Helper: Safely extract 'alias' from the info dictionary
// -----------------------------------------------------------------------------
const char* get_alias_safe(id dict) {
    if (!dict) return NULL;
    
    SEL sObjectForKey = sel_registerName("objectForKey:");
    SEL sStringWithUTF8 = sel_registerName("stringWithUTF8String:");
    SEL sLength = sel_registerName("length");
    SEL sUTF8 = sel_registerName("UTF8String");

    Class clsString = objc_getClass("NSString");
    
    // Create @"alias" key
    id (*strFactory)(id, SEL, const char*) = (id (*)(id, SEL, const char*))method_getImplementation(class_getClassMethod(clsString, sStringWithUTF8));
    id keyAlias = strFactory((id)clsString, sStringWithUTF8, "alias");

    // Get value
    id valString = NULL;
    if (class_getInstanceMethod(object_getClass(dict), sObjectForKey)) {
         id (*f)(id, SEL, id) = (id (*)(id, SEL, id))method_getImplementation(class_getInstanceMethod(object_getClass(dict), sObjectForKey));
         valString = f(dict, sObjectForKey, keyAlias);
    }
    
    if (!valString) return NULL; 

    // Verify length > 0
    if (class_getInstanceMethod(object_getClass(valString), sLength)) {
        unsigned long (*fLen)(id, SEL) = (unsigned long (*)(id, SEL))method_getImplementation(class_getInstanceMethod(object_getClass(valString), sLength));
        if (fLen(valString, sLength) == 0) return NULL;
    }

    // Convert to C String
    if (class_getInstanceMethod(object_getClass(valString), sUTF8)) {
        const char* (*f)(id, SEL) = (const char* (*)(id, SEL))method_getImplementation(class_getInstanceMethod(object_getClass(valString), sUTF8));
        return f(valString, sUTF8);
    }
    return NULL;
}

// Helper: Extract ENetPeer pointer from NSValue wrapper
ENetPeer* get_raw_peer(id peerWrapper) {
    if (!peerWrapper) return NULL;
    SEL sPtrVal = sel_registerName("pointerValue");
    if (class_getInstanceMethod(object_getClass(peerWrapper), sPtrVal)) {
        ValuePointerFunc f = (ValuePointerFunc)method_getImplementation(class_getInstanceMethod(object_getClass(peerWrapper), sPtrVal));
        return (ENetPeer*)f(peerWrapper, sPtrVal);
    }
    return NULL;
}

// -----------------------------------------------------------------------------
// Logic: Strict Name Validation
// -----------------------------------------------------------------------------
bool is_name_safe(const char* str) {
    if (!str) return false;
    size_t len = strlen(str);
    
    // Length Check (1-16)
    if (len < 1 || len > 16) return false;

    // Character Check (Alphanumeric + Underscore only)
    for (int i = 0; i < len; i++) {
        char c = str[i];
        if (!isalnum(c) && c != '_') return false;
    }
    return true;
}

// -----------------------------------------------------------------------------
// Hook 1: Entry Gate (Packet Filter)
// Blocks malicious packets before the server processes them.
// -----------------------------------------------------------------------------
void hook_PacketRecv(id self, SEL _cmd, id infoDict, id peerWrapper) {
    const char* alias = get_alias_safe(infoDict);

    if (!is_name_safe(alias)) {
        printf("[NameGuard] Blocked invalid connection attempt.\n");
        
        // Instant Socket Kill
        ENetPeer* rawPeer = get_raw_peer(peerWrapper);
        if (rawPeer && real_enet_peer_disconnect_now) {
            real_enet_peer_disconnect_now(rawPeer, 0);
        }
        return; 
    }

    if (original_auth) original_auth(self, _cmd, infoDict, peerWrapper);
}

// -----------------------------------------------------------------------------
// Hook 2: Backdoor Seal (Anti-Reconnect)
// Disables 'clientReconnected' to prevent session hijacking via slot reuse.
// -----------------------------------------------------------------------------
void hook_Reconnect_Neutralizer(id self, SEL _cmd) {
    // Intentionally empty. Forces client to send full authentication.
}

// -----------------------------------------------------------------------------
// Hook 3: Session Shredder (Cleanup)
// Resets the ENet peer on disconnect to remove "Zombie Slots".
// -----------------------------------------------------------------------------
void hook_Disconnect_Cleanup(id self, SEL _cmd, id peerWrapper, bool wasKick) {
    if (original_disconnect) {
        original_disconnect(self, _cmd, peerWrapper, wasKick);
    }

    // Hard reset of the peer connection
    ENetPeer* rawPeer = get_raw_peer(peerWrapper);
    if (rawPeer && real_enet_peer_reset) {
        real_enet_peer_reset(rawPeer);
    }
}

// -----------------------------------------------------------------------------
// Initialization
// -----------------------------------------------------------------------------
static void *patchThread(void *arg) {
    printf("[NameGuard] Waiting for Runtime...\n");
    
    // Spin-lock: Wait for server classes to load (Fixes startup race condition)
    int checks = 0;
    while (!objc_getClass(CLASS_MATCH) || !objc_getClass(CLASS_CLIENT)) {
        usleep(1000); // Check every 1ms
        checks++;
        if (checks > 15000) return NULL; // Timeout
    }
    
    resolve_enet_symbols();

    // Hook BHNetServerMatch
    Class clsMatch = objc_getClass(CLASS_MATCH);
    if (clsMatch) {
        // Auth
        SEL s1 = sel_registerName(SEL_AUTH);
        Method m1 = class_getInstanceMethod(clsMatch, s1);
        if (m1) {
            original_auth = (void (*)(id, SEL, id, id))method_getImplementation(m1);
            method_setImplementation(m1, (IMP)hook_PacketRecv);
            printf("[NameGuard] Entry Gate: Active.\n");
        }
        // Disconnect
        SEL sDisc = sel_registerName(SEL_DISCONN);
        Method mDisc = class_getInstanceMethod(clsMatch, sDisc);
        if (mDisc) {
            original_disconnect = (void (*)(id, SEL, id, bool))method_getImplementation(mDisc);
            method_setImplementation(mDisc, (IMP)hook_Disconnect_Cleanup);
            printf("[NameGuard] Session Shredder: Active.\n");
        }
    }

    // Hook ServerClient
    Class clsClient = objc_getClass(CLASS_CLIENT);
    if (clsClient) {
        // Reconnect
        SEL sReconn = sel_registerName(SEL_RECONN);
        Method mReconn = class_getInstanceMethod(clsClient, sReconn);
        if (mReconn) {
            method_setImplementation(mReconn, (IMP)hook_Reconnect_Neutralizer);
            printf("[NameGuard] Reconnect Bypass: Sealed.\n");
        }
    }
    
    return NULL;
}

__attribute__((constructor))
static void init_hook() {
    pthread_t t;
    pthread_create(&t, NULL, patchThread, NULL);
}
