/*
 * Auth Blocker v12.0
 * Target: BHNetServerMatch
 * Logic: Catch the login packet, check the name.
 * If the name is trash (empty, too long, weird symbols), we kill the connection instantly.
 * No bypasses allowed.
 */

#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <unistd.h>
#include <dlfcn.h>
#include <pthread.h>
#include <stdbool.h>
#include <stdint.h>
#include <objc/runtime.h>
#include <objc/message.h>

// The login function (Typo "Recieved" is in the game code, lol)
#define TARGET_SEL "clientPlayerInformationRecieved:fromPeer:"

// Need this to nuke the connection
typedef struct _ENetPeer ENetPeer;
typedef void (*DisconnectFunc)(ENetPeer *, uint32_t);
static DisconnectFunc enet_peer_disconnect_now = NULL;

// Func pointers
typedef void (*AuthFunc)(id, SEL, id, id); 
typedef id (*ObjForKeyFunc)(id, SEL, id);  
typedef const char* (*Utf8Func)(id, SEL);
typedef void* (*ValuePointerFunc)(id, SEL); 

static AuthFunc original_auth = NULL;

// -----------------------------------------------------------------------------
// Name Policy
// -----------------------------------------------------------------------------
bool is_valid_name(const char* str) {
    if (!str) return false;
    size_t len = strlen(str);

    // 1-16 chars. No empty names, no paragraphs.
    if (len < 1 || len > 16) return false;

    // Only letters, numbers, underscore. No emojis, no invisible chars.
    for (int i = 0; i < len; i++) {
        char c = str[i];
        if (!isascii(c)) return false; 
        if (!isalnum(c) && c != '_') return false;
    }
    return true;
}

// -----------------------------------------------------------------------------
// Helper: Dig the name out of the dictionary
// -----------------------------------------------------------------------------
const char* get_alias_from_dict(id dict) {
    if (!dict) return NULL;
    
    SEL sObjectForKey = sel_registerName("objectForKey:");
    
    // Need to make an NSString @"alias" to query the dict
    Class clsString = objc_getClass("NSString");
    SEL sStringWithUTF8 = sel_registerName("stringWithUTF8String:");
    id (*strFactory)(id, SEL, const char*) = (id (*)(id, SEL, const char*))method_getImplementation(class_getClassMethod(clsString, sStringWithUTF8));
    
    // Cast to (id) to shut up the compiler warnings
    id keyAlias = strFactory((id)clsString, sStringWithUTF8, "alias");

    // Get the value
    id valString = NULL;
    if (class_getInstanceMethod(object_getClass(dict), sObjectForKey)) {
         ObjForKeyFunc f = (ObjForKeyFunc)method_getImplementation(class_getInstanceMethod(object_getClass(dict), sObjectForKey));
         valString = f(dict, sObjectForKey, keyAlias);
    }

    if (!valString) return NULL;

    // Convert NSString -> C String
    SEL sUTF8 = sel_registerName("UTF8String");
    if (class_getInstanceMethod(object_getClass(valString), sUTF8)) {
        Utf8Func f = (Utf8Func)method_getImplementation(class_getInstanceMethod(object_getClass(valString), sUTF8));
        return f(valString, sUTF8);
    }

    return NULL;
}

// -----------------------------------------------------------------------------
// Helper: Unwrap the ENetPeer from the NSValue wrapper
// -----------------------------------------------------------------------------
ENetPeer* get_raw_peer(id peerObj) {
    if (!peerObj) return NULL;
    SEL sPtrVal = sel_registerName("pointerValue");
    if (class_getInstanceMethod(object_getClass(peerObj), sPtrVal)) {
        ValuePointerFunc f = (ValuePointerFunc)method_getImplementation(class_getInstanceMethod(object_getClass(peerObj), sPtrVal));
        return (ENetPeer*)f(peerObj, sPtrVal);
    }
    return NULL;
}

// -----------------------------------------------------------------------------
// THE HOOK: Gatekeeper + Kill Switch
// -----------------------------------------------------------------------------
void hook_Auth(id self, SEL _cmd, id infoDict, id peerWrapper) {
    
    const char* alias = get_alias_from_dict(infoDict);

    if (!is_valid_name(alias)) {
        printf("[AuthBlocker] BAD NAME: '%s'. Nuking connection.\n", alias ? alias : "NULL");
        
        // Load ENet function if we haven't yet
        if (!enet_peer_disconnect_now) {
            enet_peer_disconnect_now = (DisconnectFunc)dlsym(RTLD_NEXT, "enet_peer_disconnect_now");
        }

        // Get the real peer pointer
        ENetPeer* rawPeer = get_raw_peer(peerWrapper);

        // Kill it.
        if (rawPeer && enet_peer_disconnect_now) {
            enet_peer_disconnect_now(rawPeer, 0);
            printf("[AuthBlocker] Peer disconnected.\n");
        }

        return; // Don't let the server see this packet
    }

    // Name is clean, let 'em in.
    if (original_auth) {
        original_auth(self, _cmd, infoDict, peerWrapper);
    }
}

// -----------------------------------------------------------------------------
// Setup
// -----------------------------------------------------------------------------
void try_hook_class(const char* className, SEL selector) {
    if (original_auth != NULL) return; // Already hooked one
    Class cls = objc_getClass(className);
    if (!cls) return;

    Method method = class_getInstanceMethod(cls, selector);
    if (method) {
        printf("[AuthBlocker] Found target: %s. Hooking...\n", className);
        original_auth = (AuthFunc)method_getImplementation(method);
        method_setImplementation(method, (IMP)hook_Auth);
        printf("[AuthBlocker] Hook installed.\n");
    }
}

static void *patchThread(void *arg) {
    printf("[AuthBlocker] Loading v12.0...\n");
    sleep(2); 
    
    // Memory Pool to keep the runtime happy
    Class clsPool = objc_getClass("NSAutoreleasePool");
    SEL sNew = sel_registerName("new");
    SEL sDrain = sel_registerName("drain");
    id (*newPool)(id, SEL) = (id (*)(id, SEL))method_getImplementation(class_getClassMethod(clsPool, sNew));
    void (*drainPool)(id, SEL) = (void (*)(id, SEL))method_getImplementation(class_getInstanceMethod(clsPool, sDrain));
    
    id pool = newPool((id)clsPool, sNew);

    SEL selector = sel_registerName(TARGET_SEL);

    // Try the usual suspects
    try_hook_class("BHNetServerMatch", selector); 
    try_hook_class("BHMatch", selector);
    try_hook_class("BHServer", selector);

    if (!original_auth) {
        printf("[AuthBlocker] ERROR: Couldn't find the auth method.\n");
    } else {
        printf("[AuthBlocker] Ready. Bad names get kicked.\n");
    }

    drainPool(pool, sDrain);
    return NULL;
}

__attribute__((constructor))
static void init_hook() {
    pthread_t t;
    pthread_create(&t, NULL, patchThread, NULL);
}
