/*
 * Name Exploit Fixer V12 (Multi-Class Defense)
 * 1. Target A (BHNetServerMatch): Blocks Invalid Names at Packet Gate.
 * 2. Target A (BHNetServerMatch): Uses 'enet_peer_disconnect_now' for instant kill.
 * 3. Target B (ServerClient): Neutralizes 'clientReconnected' to prevent bypass.
 * 4. Force-closes the "reconnect loophole".
 */

#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <unistd.h>
#include <dlfcn.h>
#include <pthread.h>
#include <stdbool.h>
#include <stdint.h>
#include <objc/runtime.h>
#include <objc/message.h>

// -----------------------------------------------------------------------------
// CONFIGURATION
// -----------------------------------------------------------------------------

// TARGET A: The Reception Desk
#define CLASS_MATCH   "BHNetServerMatch"
#define SEL_AUTH      "clientPlayerInformationRecieved:fromPeer:" 
#define SEL_APPROVE   "clientApprovedWithInfo:"                   

// TARGET B: The Player File (Backdoor)
#define CLASS_CLIENT  "ServerClient"
#define SEL_RECONN    "clientReconnected" 

// ENet Structures
typedef struct _ENetPeer ENetPeer;
typedef void (*DisconnectFunc)(ENetPeer *, uint32_t);

// Function Pointers
static DisconnectFunc real_enet_peer_disconnect_now = NULL;
static void (*original_auth)(id, SEL, id, id) = NULL;
static void (*original_approve)(id, SEL, id) = NULL;
// We don't need original_reconnect because we will never call it.

// Helper Types
typedef void* (*ValuePointerFunc)(id, SEL); 

// -----------------------------------------------------------------------------
// SYMBOL RESOLUTION
// -----------------------------------------------------------------------------
void resolve_enet_symbols() {
    void* handle = dlopen(NULL, RTLD_NOW);
    if (!handle) {
        printf("[NameGuard] ERROR: Could not open main executable handle.\n");
        return;
    }
    real_enet_peer_disconnect_now = (DisconnectFunc)dlsym(handle, "enet_peer_disconnect_now");

    if (real_enet_peer_disconnect_now) {
        printf("[NameGuard] WEAPON: 'enet_peer_disconnect_now' loaded.\n");
    } else {
        printf("[NameGuard] WARNING: Silent Mode (Ghosting) active.\n");
    }
}

// -----------------------------------------------------------------------------
// HELPER: Extract Name
// -----------------------------------------------------------------------------
const char* get_alias_safe(id dict) {
    if (!dict) return NULL;
    SEL sObjectForKey = sel_registerName("objectForKey:");
    Class clsString = objc_getClass("NSString");
    SEL sStringWithUTF8 = sel_registerName("stringWithUTF8String:");
    
    id (*strFactory)(id, SEL, const char*) = (id (*)(id, SEL, const char*))method_getImplementation(class_getClassMethod(clsString, sStringWithUTF8));
    id keyAlias = strFactory((id)clsString, sStringWithUTF8, "alias");

    id valString = NULL;
    if (class_getInstanceMethod(object_getClass(dict), sObjectForKey)) {
         id (*f)(id, SEL, id) = (id (*)(id, SEL, id))method_getImplementation(class_getInstanceMethod(object_getClass(dict), sObjectForKey));
         valString = f(dict, sObjectForKey, keyAlias);
    }
    if (!valString) return NULL;

    SEL sLength = sel_registerName("length");
    if (class_getInstanceMethod(object_getClass(valString), sLength)) {
        unsigned long (*fLen)(id, SEL) = (unsigned long (*)(id, SEL))method_getImplementation(class_getInstanceMethod(object_getClass(valString), sLength));
        if (fLen(valString, sLength) == 0) return NULL;
    }

    SEL sUTF8 = sel_registerName("UTF8String");
    if (class_getInstanceMethod(object_getClass(valString), sUTF8)) {
        const char* (*f)(id, SEL) = (const char* (*)(id, SEL))method_getImplementation(class_getInstanceMethod(object_getClass(valString), sUTF8));
        return f(valString, sUTF8);
    }
    return NULL;
}

ENetPeer* get_raw_peer(id peerWrapper) {
    if (!peerWrapper) return NULL;
    SEL sPtrVal = sel_registerName("pointerValue");
    if (class_getInstanceMethod(object_getClass(peerWrapper), sPtrVal)) {
        ValuePointerFunc f = (ValuePointerFunc)method_getImplementation(class_getInstanceMethod(object_getClass(peerWrapper), sPtrVal));
        return (ENetPeer*)f(peerWrapper, sPtrVal);
    }
    return NULL;
}

// -----------------------------------------------------------------------------
// LOGIC
// -----------------------------------------------------------------------------
bool is_name_safe(const char* str) {
    if (!str) return false;
    size_t len = strlen(str);
    if (len < 1 || len > 16) return false;
    for (int i = 0; i < len; i++) {
        char c = str[i];
        if (!isalnum(c) && c != '_') return false;
    }
    return true;
}

// HOOK 1: Main Gate (Standard Auth)
void hook_PacketRecv(id self, SEL _cmd, id infoDict, id peerWrapper) {
    const char* alias = get_alias_safe(infoDict);

    if (!is_name_safe(alias)) {
        printf("[NameGuard] üõë BLOCKED at Packet Gate.\n");
        
        ENetPeer* rawPeer = get_raw_peer(peerWrapper);
        if (rawPeer && real_enet_peer_disconnect_now) {
            printf("[NameGuard] Executing Socket Kill...\n");
            real_enet_peer_disconnect_now(rawPeer, 0);
        }
        return; 
    }
    if (original_auth) original_auth(self, _cmd, infoDict, peerWrapper);
}

// HOOK 2: Approval (Safety Net)
void hook_Approve(id self, SEL _cmd, id infoDict) {
    const char* alias = get_alias_safe(infoDict);
    if (!is_name_safe(alias)) {
        printf("[NameGuard] üõë BLOCKED at Approval Gate.\n");
        return;
    }
    if (original_approve) original_approve(self, _cmd, infoDict);
}

// HOOK 3: Reconnection Neutralizer
// Target: ServerClient -> clientReconnected
void hook_Reconnect_Neutralizer(id self, SEL _cmd) {
    printf("[NameGuard] üõ°Ô∏è BLOCKED 'ServerClient clientReconnected'. Forcing full auth.\n");
    // We intentionally do NOTHING here.
    // By not calling original, the "I'm back" logic is broken.
    // The client MUST send a full login packet to proceed.
}

// -----------------------------------------------------------------------------
// INIT
// -----------------------------------------------------------------------------
static void *patchThread(void *arg) {
    printf("[NameGuard] Loading V12 (Multi-Class Defense)...\n");
    sleep(1); 
    
    resolve_enet_symbols();

    Class clsPool = objc_getClass("NSAutoreleasePool");
    SEL sNew = sel_registerName("new");
    SEL sDrain = sel_registerName("drain");
    id (*newPool)(id, SEL) = (id (*)(id, SEL))method_getImplementation(class_getClassMethod(clsPool, sNew));
    void (*drainPool)(id, SEL) = (void (*)(id, SEL))method_getImplementation(class_getInstanceMethod(clsPool, sDrain));
    id pool = newPool((id)clsPool, sNew);

    // --- SETUP TARGET A: BHNetServerMatch ---
    Class clsMatch = objc_getClass(CLASS_MATCH);
    if (clsMatch) {
        // Hook Auth
        SEL s1 = sel_registerName(SEL_AUTH);
        Method m1 = class_getInstanceMethod(clsMatch, s1);
        if (m1) {
            original_auth = (void (*)(id, SEL, id, id))method_getImplementation(m1);
            method_setImplementation(m1, (IMP)hook_PacketRecv);
            printf("[NameGuard] Auth Gate (BHNetServerMatch): Active.\n");
        }

        // Hook Approve
        SEL s2 = sel_registerName(SEL_APPROVE);
        Method m2 = class_getInstanceMethod(clsMatch, s2);
        if (m2) {
            original_approve = (void (*)(id, SEL, id))method_getImplementation(m2);
            method_setImplementation(m2, (IMP)hook_Approve);
            printf("[NameGuard] Approval Gate (BHNetServerMatch): Active.\n");
        }
    } else {
        printf("[NameGuard] ERROR: Class %s not found.\n", CLASS_MATCH);
    }

    // --- SETUP TARGET B: ServerClient ---
    Class clsClient = objc_getClass(CLASS_CLIENT);
    if (clsClient) {
        // Hook Reconnect to disable it
        SEL s3 = sel_registerName(SEL_RECONN);
        Method m3 = class_getInstanceMethod(clsClient, s3);
        if (m3) {
            // We don't save original because we destroy the logic
            method_setImplementation(m3, (IMP)hook_Reconnect_Neutralizer);
            printf("[NameGuard] Reconnect Bypass (ServerClient): SEALED.\n");
        } else {
             printf("[NameGuard] WARNING: 'clientReconnected' not found in ServerClient.\n");
        }
    } else {
        printf("[NameGuard] ERROR: Class %s not found.\n", CLASS_CLIENT);
    }

    drainPool(pool, sDrain);
    return NULL;
}

__attribute__((constructor))
static void init_hook() {
    pthread_t t;
    pthread_create(&t, NULL, patchThread, NULL);
}
